<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>McTT: Building A Correct-By-Construction Proof Checkers For
Type Theories</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="styling.css" />
  <script>
   window.addEventListener('load', function () {
       for (node of document.querySelectorAll('pre>code')) {
           let pre = node.parentNode;
           for (c of pre.childNodes) {
               for (cls of pre.classList) {
                   c.classList.add(cls);
               }
           }
       }
   });

   window.addEventListener('load', function () {
       let h1elem = document.querySelector('h1');
       let body = h1elem.parentNode;
       h1elem.classList.add('project_title');
       h1elem.remove();

       let bannerButton = document.createElement('a');
       bannerButton.id = 'forkme_banner';
       bannerButton.setAttribute('href', 'https://github.com/Beluga-lang/McTT');
       bannerButton.innerText = 'Fork on GitHub';

       let header = document.createElement('header');
       header.className = 'inner';
       header.append(bannerButton, h1elem);

       let headerDiv = document.createElement('div');
       headerDiv.id = 'header_wrap';
       headerDiv.className = 'outer';
       headerDiv.append(header);

       let sec = document.createElement('section');
       sec.className = 'inner';
       sec.append.apply(sec, body.childNodes);
       body.append(headerDiv, sec);
   });
  </script>
  <link rel="stylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/ebnf.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<h1
id="mctt-building-a-correct-by-construction-proof-checkers-for-type-theories">McTT:
Building A Correct-By-Construction Proof Checkers For Type Theories</h1>
<p>McTT is a verified, runnable typechecker for Martin-Löf type theory.
This project provides an executable, to which we can feed a program in
Martin-Löf type theory to check whether this program has the specified
type. McTT is novel in that it is implemented and verified in Coq. More
specifically, we proved that the typechecking algorithm extracted from
Coq is sound and complete: a program passes typechecker if and only if
it is a well-typed program in MLTT. This is the first verified proof
assistant (despite being elementary) and serves as a basis for future
extensions.</p>
<h2 id="online-documentation">Online Documentation</h2>
<p>We have generated a <a href="dep.html">Coqdoc</a> for browsing our
Coq proof.</p>
<!-- ## Architecture -->

<!-- McTT has the following architecture: -->

<!-- ``` -->

<!--     | source code of McTT -->

<!--     v -->

<!-- +-------+ -->

<!-- | lexer |          OCaml code generated by ocamllex -->

<!-- +-------+ -->

<!--     | stream of tokens -->

<!--     v -->

<!-- +--------+ -->

<!-- | parser |         Coq code generated by Menhir -->

<!-- +--------+ -->

<!--     | concrete syntax tree -->

<!--     v -->

<!-- +------------+ -->

<!-- | elaborator |     Coq code -->

<!-- +------------+ -->

<!--     | abstract syntax tree -->

<!--     v -->

<!-- +-------------+ -->

<!-- | typechecker |    Coq code -->

<!-- | (normalizer | -->

<!-- |   included) | -->

<!-- +-------------+ -->

<!--     | yes or no    Driver in OCaml -->

<!--     v -->

<!-- ``` -->

<!-- In this architecture, most code is in Coq, with accompanying theorems to justify the -->

<!-- implementation. -->

<h2 id="dependencies">Dependencies</h2>
<ul>
<li>Ocaml Dependencies
<ul>
<li><a href="https://ocaml.org/">OCaml</a> 4.14.2 or later</li>
<li><a href="http://cambium.inria.fr/~fpottier/menhir/">Menhir</a></li>
<li><a
href="https://github.com/janestreet/ppx_expect">ppx_expect</a></li>
</ul></li>
<li>Rocq Dependencies
<ul>
<li><a
href="https://gitlab.inria.fr/fpottier/menhir/-/tree/master/coq-menhirlib">Coq-Menhirlib</a></li>
<li><a href="https://coq.inria.fr/">Coq</a> 8.20.0</li>
<li><a
href="https://github.com/mattam82/Coq-Equations">Coq-Equations</a>
1.3</li>
</ul></li>
</ul>
<p>We recommend to install dependencies in the following way in the top
directory of this project:</p>
<pre class="bash"><code># setup OPAM switch
opam update
opam switch create coq-8.20.0 5.3.0
opam switch coq-8.20.0
eval $(opam env)

# install Rocq
opam pin -y add coq 8.20.0
opam repo add coq-released https://coq.inria.fr/opam/released

# install dependencies
opam install -y dune
dune build mctt.opam
opam install -y --deps-only .</code></pre>
<h2 id="build-from-source">Build From Source</h2>
<p>Use the toplevel <code>make</code> to build the whole project:</p>
<pre><code>make</code></pre>
<p>Makefile will try to find out the number of your CPU cores and
parallel as much as possible.</p>
<p>Once <code>make</code> finishes, you can run the binary:</p>
<pre><code>dune exec mctt examples/nary.mctt # or your own example</code></pre>
<p>or more directly</p>
<pre><code>_build/default/driver/mctt.exe examples/nary.mctt # or your own example</code></pre>
<p>To build Coq proof only, you can go into and only build the
<code>theories</code> directory:</p>
<pre><code>cd theories
make</code></pre>
<h2 id="external-syntax">External Syntax</h2>
<p>Our interpreter accepts a <code>prog</code>, defined in the following
grammar (written in <a
href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF</a>):</p>
<pre class="EBNF"><code>prog = term , &#39;:&#39; , type;

type = term;
     (* function type *)
term = &#39;forall&#39; , {parameter} , &#39;-&gt;&#39; , term
     (* function *)
     | &#39;fun&#39; , {parameter} , &#39;-&gt;&#39; , term
     (* pair type *)
     | &#39;exists&#39; , {parameter} , &#39;-&gt;&#39; , term
     (* application *)
     | application term
     (* let expression *)
     | &#39;let&#39; , {let definition} , &#39;in&#39; , term
     (* successor of a natural number *)
     | &#39;succ&#39; , atomic term
     (* natural number eliminator *)
     | &#39;rec&#39; , term , nat scrutinee type? , &#39;return&#39; , nat motive , zero branch , succ branch , &#39;end&#39;
     (* propositional equality type *)
     | application term , &#39;=&#39; , &#39;{&#39; , type , &#39;}&#39; , application term
     (* reflexivity for propositional equality *)
     | &#39;refl&#39; , atomic type , atomic term
     (* propositional equality eliminator *)
     | &#39;rec&#39; , term , equality scrutinee type , &#39;return&#39; , equality motive , refl branch , &#39;end&#39;
     (* first projection of a pair *)
     | &#39;fst&#39; , atomic term
     (* second projection of a pair *)
     | &#39;snd&#39; , atomic term;

application term = {atomic term};

atomic type = atomic term;
            (* universe of level n *)
atomic term = &#39;Type&#39;, &#39;@&#39; , nat
            (* natural number type *)
            | &#39;Nat&#39;
            (* natural number zero *)
            | &#39;zero&#39;
            (* a shorthand for succ (succ (... (succ zero))) *)
            | nat
            (* variable *)
            | id
            (* pair term *)
            | &#39;&lt;&#39; , term , &#39;:&#39; , type , &#39;,&#39; , term , &#39;:&#39; id , &#39;.&#39; , type &#39;&gt;&#39;
            (* parenthesized term *)
            | &#39;(&#39; , term , &#39;)&#39;;

parameter = &#39;(&#39; , id , &#39;:&#39; , type , &#39;)&#39;;

let definition = &#39;(&#39; , parameter , &#39;:=&#39; , term , &#39;)&#39;;

nat scrutinee type = &#39;as&#39; , &#39;nat&#39;;

(* This describes the return type of the nat eliminator
   when id is bound to the scrutinee *)
nat motive = id , &#39;.&#39; , type;

zero branch = &#39;|&#39;, &#39;zero&#39; , &#39;=&gt;&#39; , term;

(* the first id is predecessor
   and the second id is the result of the recursive call *)
succ branch = &#39;|&#39;, &#39;succ&#39; , id , id , &#39;=&gt;&#39; , term;

equality scrutinee type = &#39;as&#39; , &#39;(&#39; , application term , &#39;=&#39; , &#39;{&#39; , type , &#39;}&#39; , application term , &#39;)&#39;;

(* This describes the return type of the equality eliminator
   when the first id is bound to the LHS of the type of the scrutinee;
   the second id is bound to the RHS of the type of the scrutinee;
   and the third id is bound to the scrutinee *)
equality motive = id , id , id , &#39;.&#39; , type;

(* the id is bound to the LHS, which is identical to RHS *)
refl branch = &#39;|&#39;, &#39;refl&#39; , id , &#39;=&gt;&#39; , term;

id = ? sequence of upper- or lower-case ASCII alphabet characters ?;
nat = ? natural number ?;</code></pre>
<p>Here, we omit spaces between tokens. Note that the current let
expression does not support delta reduction.</p>
<h2 id="branches">Branches</h2>
<p>The Github repo includes the following special branches:</p>
<ol type="1">
<li><code>main</code>: the main branch that is used to generate this
homepage and Coqdoc;</li>
<li><code>ext/*</code>: branches in this pattern are variations of
<code>main</code> that implements various extensions. They are often
used to implement extensions that require non-trivial workload and are
aimed to be merged to <code>main</code> eventually;</li>
<li><code>icfp25</code>: the branch containing artifact for the ICFP'25
publication<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>;</li>
<li><code>gh-pages</code>: the branch to host the homepage.</li>
</ol>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Junyoung Jang, Antoine Gaulin, Jason
Z.S. Hu, and Brigitte Pientka. 2025. McTT: A Verified Kernel for a Proof
Assistant. <em>Proc. ACM Program. Lang.</em>, ICFP (2025), <a
href="https://doi.org/10.1145/3747511">https://doi.org/10.1145/3747511</a><a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
