# McTT: Building A Correct-By-Construction Proof Checkers For Type Theories

McTT is a verified, runnable typechecker for Martin-Löf type theory. This project provides an executable, to which we can feed
a program in Martin-Löf type theory to check whether this
program has the specified type. McTT is novel in that it is implemented and verified in
Rocq. More specifically, we proved that the typechecking algorithm extracted from Rocq is
sound and complete: a program passes typechecker if and only if it is a well-typed
program in MLTT. This is the first verified proof assistant (despite being
elementary) and serves as a basis for future extensions.

## Online Documentation

We have generated a [Rocqdoc](https://beluga-lang.github.io/McTT/dep.html) for browsing our Rocq proof.

## Architecture

McTT has the following architecture:

```
    | source code of McTT
    v
+-------+
| lexer |          OCaml code generated by ocamllex
+-------+
    | stream of tokens
    v
+--------+
| parser |         Rocq code generated by Menhir
+--------+
    | concrete syntax tree
    v
+------------+
| elaborator |     Rocq code
+------------+
    | abstract syntax tree
    v
+-------------+
| typechecker |    Rocq code
| (normalizer |
|   included) |
+-------------+
    | yes or no    Driver in OCaml
    v
```

In this architecture, most code is in Rocq, with accompanying theorems to justify the
implementation.


## Dependencies

* [OCaml](https://ocaml.org/) 4.14.2
* [Rocq](https://rocq-prover.org) 9.0.0
* [Rocq-Equations](https://github.com/mattam82/Coq-Equations) 1.3
* [Menhir](http://cambium.inria.fr/~fpottier/menhir/)
* [Coq-Menhirlib](https://gitlab.inria.fr/fpottier/menhir/-/tree/master/coq-menhirlib)

We recommend to install dependencies in the following way:

```bash
opam update
opam switch create rocq 4.14.2
opam pin add rocq-prover 9.0.0
opam repo add rocq-released https://rocq-prover.org/opam/released
opam install -y rocq-equations menhir coq-menhirlib ppx_inline_test ppx_expect
```

## Development

Use the toplevel `make` to build the whole project:
```
make
```
Makefile will try to find out the number of your CPU cores and parallel as much as
possible.

Once `make` finishes, you can run the binary:
```
dune exec mctt examples/nary.mctt # or your own example
```
or more directly
```
_build/default/driver/mctt.exe examples/nary.mctt # or your own example
```

To build Rocq proof only, you can go into and only build the `theories` directory:
```
cd theories
make
```
## External Syntax

Our interpreter accepts a `prog`, defined in the following grammar
(written in
[EBNF](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form)):

```EBNF
prog = term , ':' , type;

type = term;
     (* function type *)
term = 'forall' , {parameter} , '->' , term
     (* function *)
     | 'fun' , {parameter} , '->' , term
     (* pair type *)
     | 'exists' , {parameter} , '->' , term
     (* application *)
     | application term
     (* let expression *)
     | 'let' , {let definition} , 'in' , term
     (* successor of a natural number *)
     | 'succ' , atomic term
     (* natural number eliminator *)
     | 'rec' , term , nat scrutinee type? , 'return' , nat motive , zero branch , succ branch , 'end'
     (* propositional equality type *)
     | application term , '=' , '{' , type , '}' , application term
     (* reflexivity for propositional equality *)
     | 'refl' , atomic type , atomic term
     (* propositional equality eliminator *)
     | 'rec' , term , equality scrutinee type , 'return' , equality motive , refl branch , 'end'
     (* first projection of a pair *)
     | 'fst' , atomic term
     (* second projection of a pair *)
     | 'snd' , atomic term;

application term = {atomic term};

atomic type = atomic term;
            (* universe of level n *)
atomic term = 'Type', '@' , nat
            (* natural number type *)
            | 'Nat'
            (* natural number zero *)
            | 'zero'
            (* a shorthand for succ (succ (... (succ zero))) *)
            | nat
            (* variable *)
            | id
            (* pair term *)
            | '<' , term , ':' , type , ',' , term , ':' id , '.' , type '>'
            (* parenthesized term *)
            | '(' , term , ')';

parameter = '(' , id , ':' , type , ')';

let definition = '(' , parameter , ':=' , term , ')';

nat scrutinee type = 'as' , 'nat';

(* This describes the return type of the nat eliminator
   when id is bound to the scrutinee *)
nat motive = id , '.' , type;

zero branch = '|', 'zero' , '=>' , term;

(* the first id is predecessor
   and the second id is the result of the recursive call *)
succ branch = '|', 'succ' , id , id , '=>' , term;

equality scrutinee type = 'as' , '(' , application term , '=' , '{' , type , '}' , application term , ')';

(* This describes the return type of the equality eliminator
   when the first id is bound to the LHS of the type of the scrutinee;
   the second id is bound to the RHS of the type of the scrutinee;
   and the third id is bound to the scrutinee *)
equality motive = id , id , id , '.' , type;

(* the id is bound to the LHS, which is identical to RHS *)
refl branch = '|', 'refl' , id , '=>' , term;

id = ? sequence of upper- or lower-case ASCII alphabet characters ?;
nat = ? natural number ?;
```

Here, we omit spaces between tokens. Note that the current let
expression does not support delta reduction.

## Branches

The Github repo includes the following special branches:

1. `main`: the main branch that is used to generate the main homepage and Rocqdoc;
1. `ext/*`: branches in this pattern are variations of `main` that implements various extensions. They are often used to implement extensions that require non-trivial workload and are aimed to be merged to `main` eventually;
1. `icfp25`: the branch containing artifact for the ICFP'25 publication[^1];
1. `gh-pages`: the branch to host the homepage.

[^1]: Junyoung Jang, Antoine Gaulin, Jason Z.S. Hu, and Brigitte Pientka. 2025. McTT: A Verified Kernel for a Proof Assistant. _Proc. ACM Program. Lang._, ICFP (2025), https://doi.org/10.1145/3747511
